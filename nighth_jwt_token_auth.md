# JWT Token Authentication

![Screenshot 2021-11-16 at 23 43 00](https://user-images.githubusercontent.com/11652564/142041963-cd1b5578-4aeb-44c6-9ae2-230975cccdce.png)

(1) (`Client`): `Client` will Login with username and password to the `server` using the API created

(2) (`API`): if credentials are valid then the API will sigh a JWT token and send back the token to the client

(3) (`Client`): Client request for a post, so, the post id along with token will be sent to API, API will first verify the token

(4) (`API`) if the toke matched, then the related data will be sent to the client

![Screenshot 2021-11-16 at 23 47 31](https://user-images.githubusercontent.com/11652564/142042596-9fc68b08-41bc-4899-8690-3f2739a013a7.png)

- **NOTE:** token is not encrypted at any step this is done to just check if the data collected i s not manuplulated, token is made made up of three pieces:

(1) **HEADER**: Algo (ex: alh: HS256) and token type (ex: typ: JWT)

(2) **PAYLOAD**: Data (so, payload is also not encrypted, so the data can be such as **id**, or user type (admin, dev)): **NOTE**: we always want to keeep the payload light

(3) **VERIFY SIGNATURE**:
    - `header`: as menntioned above with base64 encode
    - `payload`: as mentioned above with base64 encode
    - `secret`: **unique password** will be known by API client
    - the combination of three will be a `signature` with base64 encode, again note, this signature will not be encrypted, this is created to just to be sure that **the three data collected** is not happered (manipulated) by anymean.

![Screenshot 2021-11-16 at 23 59 34](https://user-images.githubusercontent.com/11652564/142044360-12219299-1657-400e-95c8-b828f6cd93b2.png)

- it will be blocked as the `secret`: **unique password** will be known by API client
- **NOTE**: anyone can see the token but can't created a new token to manupulate the data as it will require the secreat and we know the secreat used a uique password which was generated by API, therefore anyone see the token but generate a new token which passes this authentication.

![Screenshot 2021-11-17 at 00 11 33](https://user-images.githubusercontent.com/11652564/142045988-f9dfa466-70de-4608-b625-2e7ff207ec00.png)

- **schemas.py**

```
class UserLogin(BaseModel):
    email: EmailStr
    password: str
```
- **utils.py**

```
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto") # what is hashing algo to be used

def hash(password: str):
    return pwd_context.hash(password)


def verify(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

```

- **auth.py**

```
from fastapi import FastAPI, Response, status, HTTPException, Depends, APIRouter
from sqlalchemy.orm import Session # database session
from .. import database, schemas, models, utils
from ..database import get_db

router = APIRouter(tags=["Authentication"])


@router.post("/login") # user has to provide the cred
def login(user_credentials: schemas.UserLogin, db: Session = Depends(get_db)):
    user = db.query(models.User).filter(models.User.email == user_credentials.email).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Invalid Credentials")

    if not utils.verify(user_credentials.password, user.password):
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Invalid Credentials")

    # create a token
    # return token
    return {"token": "example"}
```

- **main.py** `apptest.include_router(auth.router)`

```
from fastapi import FastAPI
from .database import engine
from .routers import post, user, auth
from . import models

models.Base.metadata.create_all(bind=engine)

apptest = FastAPI()

apptest.include_router(post.router)
apptest.include_router(user.router)
apptest.include_router(auth.router)


@apptest.get("/")
def root():
    return "Welcome Family"
```

## python-jose

https://fastapi.tiangolo.com/pt/tutorial/security/oauth2-jwt/#install-python-jose

- We need to install python-jose to generate and verify the JWT tokens in Python


- **oauth.py**

```
from jose import JWTError, jwt
from datetime import datetime, timedelta

# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30 # min

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.now() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})

    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

    return encoded_jwt
```

- **auth.py**

```
from fastapi import FastAPI, Response, status, HTTPException, Depends, APIRouter
from sqlalchemy.orm import Session # database session
from .. import database, schemas, models, utils, oauth
from ..database import get_db

router = APIRouter(tags=["Authentication"])


@router.post("/login") # user has to provide the cred
def login(user_credentials: schemas.UserLogin, db: Session = Depends(get_db)):
    user = db.query(models.User).filter(models.User.email == user_credentials.email).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Invalid Credentials")

    if not utils.verify(user_credentials.password, user.password):
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Invalid Credentials")

    # create a token
    # return token
    access_token = oauth.create_access_token(data={"user_id": user.id}) # payload data

    return {"access_token": access_token, "token_type": "nearer"}
```

- `http://127.0.0.1:8000/login` (POST)

- input

```
{
    "email": "nick1@gmail.com",
    "password": "nick1"
}
```

- output

```
{
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo4LCJleHAiOjE2MzczNjQ1Njl9.kpk_BwO_ixYypyk5VmxlilXNrpV2xOAaj2MHlHh_lCU",
    "token_type": "nearer"
}
```

- `OAuth2PasswordRequestForm` --> provides the dependencies

- auth.py
```
from fastapi import FastAPI, Response, status, HTTPException, Depends, APIRouter
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session # database session
from .. import database, schemas, models, utils, oauth
from ..database import get_db

router = APIRouter(tags=["Authentication"])


@router.post("/login") # user has to provide the cred
def login(user_credentials: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):

    user = db.query(models.User).filter(models.User.email == user_credentials.username).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Invalid Credentials")

    if not utils.verify(user_credentials.password, user.password):
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Invalid Credentials")

    # create a token
    # return token
    access_token = oauth.create_access_token(data={"user_id": user.id}) # payload data

    return {"access_token": access_token, "token_type": "nearer"}

```

- new we use the `http://127.0.0.1:8000/login` (post) it will throw an error

```
{
    "email": "nick1@gmail.com",
    "password": "nick1"
}
```

```
{
    "detail": [
        {
            "loc": [
                "body",
                "username"
            ],
            "msg": "field required",
            "type": "value_error.missing"
        },
        {
            "loc": [
                "body",
                "password"
            ],
            "msg": "field required",
            "type": "value_error.missing"
        }
    ]
}
```
<img width="1021" alt="Screenshot 2021-11-19 at 23 32 31" src="https://user-images.githubusercontent.com/11652564/142670032-81c78cc8-6b0b-411b-8227-34d05671e8fe.png">

## Target is to force user to first login to create any post

- `auth.py`
```
from fastapi import FastAPI, Response, status, HTTPException, Depends, APIRouter
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session # database session
from .. import database, schemas, models, utils, oauth2
from ..database import get_db

router = APIRouter(tags=["Authentication"])


@router.post("/login") # user has to provide the cred
def login(user_credentials: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):

    user = db.query(models.User).filter(models.User.email == user_credentials.username).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN,
                            detail=f"Invalid Credentials")

    if not utils.verify(user_credentials.password, user.password):
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN,
                            detail=f"Invalid Credentials")

    # create a token
    # return token
    access_token = oauth2.create_access_token(data={"user_id": user.id}) # payload data

    return {"access_token": access_token, "token_type": "nearer"}

```

- `oauth2.py`

```
from jose import JWTError, jwt
from datetime import datetime, timedelta
from . import schemas
from fastapi.security import OAuth2PasswordBearer
from fastapi import Depends, HTTPException, status


oauth_scheme = OAuth2PasswordBearer(tokenUrl='token')


# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30 # min

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})

    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

    return encoded_jwt


def verify_access_token(token: str, credentials_exception):
    try:
        print(token)
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        id: str = payload.get("user_id")

        if id is None:
            raise credentials_exception
        token_data = schemas.TokenData(id=id)
    except JWTError:
        raise credentials_exception

    return token_data

def get_curent_user(token: str = Depends(oauth_scheme)):
    credentials_exception = HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,
                                          detail=f"Could not validate credentials",
                                          headers={"WWW-Authenicate": "Bearer"})
    return verify_access_token(token, credentials_exception)
```

- `schemas.py`
```
class UserLogin(BaseModel):
    email: EmailStr
    password: str

class Token(BaseModel):
    access_token: str
    token_type = str

class TokenData(BaseModel):
    id: Optional[str] = None
```

- `post.py`

```
@router.post("/", status_code=status.HTTP_201_CREATED, response_model=schemas.Post)
def create_posts(post: schemas.PostCreate, db: Session = Depends(get_db),
                 user_id: int = Depends(oauth2.get_curent_user)):
                 # this will force the user is logged in
    print(user_id)
    new_post = models.Post(**post.dict())
    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return new_post
```

- now trying to create a post `http://127.0.0.1:8000/posts` (post)

```
{
    "detail": "Not authenticated"
}
```
<img width="1019" alt="Screenshot 2021-11-20 at 12 42 02" src="https://user-images.githubusercontent.com/11652564/142718008-324e6e1c-a356-4295-8224-40bff93c41cf.png">


- let first login with a user and use the token to create the post `http://127.0.0.1:8000/login`

- output
```
{
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo4LCJleHAiOjE2MzczOTQxNDl9.H8HlkYAe4ktxE17uVSeRZbQ5bWB1kJpSjEZk4J49oiQ",
    "token_type": "nearer"
}
```
<img width="1030" alt="Screenshot 2021-11-20 at 12 49 40" src="https://user-images.githubusercontent.com/11652564/142718241-07c9fb8a-f5fa-44cb-b0d9-418fb612ef44.png">

- now, lets create the post using this token, this token has to used in the header
<img width="989" alt="Screenshot 2021-11-20 at 12 50 33" src="https://user-images.githubusercontent.com/11652564/142718254-ce34d4a2-5ea6-4360-8c57-0b7bcad147d8.png">

- adding the authorization to other methods as well, deleting, updating and getting

```
from fastapi import FastAPI, Response, status, HTTPException, Depends, APIRouter
from sqlalchemy.orm import Session
from typing import List
from .. import models, schemas, oauth2
from ..database import get_db

router = APIRouter(
    prefix="/posts",
    tags=["Posts"]
)

@router.get("/", response_model=List[schemas.Post])
def get_posts(db: Session = Depends(get_db), user_id: int = Depends(oauth2.get_curent_user)):
    posts = db.query(models.Post).all()
    return posts


@router.post("/", status_code=status.HTTP_201_CREATED, response_model=schemas.Post)
def create_posts(post: schemas.PostCreate, db: Session = Depends(get_db),
                 user_id: int = Depends(oauth2.get_curent_user)):
                 # this will force the user is logged in
    print(user_id)
    new_post = models.Post(**post.dict())
    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return new_post

@router.get("/{id}", response_model=schemas.Post)
def get_post(id: int, db: Session = Depends(get_db), user_id: int = Depends(oauth2.get_curent_user)):
    post = db.query(models.Post).filter(models.Post.id == id).first()
    if not post:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"post with id: {id} was not found")
    return post


@router.delete("/{id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(id: int, db: Session = Depends(get_db),
                user_id: int = Depends(oauth2.get_curent_user)):
    post = db.query(models.Post).filter(models.Post.id == id)

    if post.first() == None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"post with id: {id} was not found")

    post.delete(synchronize_session=False)
    db.commit()
    return Response(status_code=status.HTTP_204_NO_CONTENT)


@router.put("/{id}", response_model=schemas.Post)
def update_post(id: int, updated_post: schemas.PostCreate, db: Session = Depends(get_db),
                user_id: int = Depends(oauth2.get_curent_user)):
    post_query = db.query(models.Post).filter(models.Post.id == id)
    post = post_query.first()

    if post == None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"post with id: {id} was not found")

    post_query.update(updated_post.dict(), synchronize_session=False)
    db.commit()
    return post_query.first()

```
<img width="1005" alt="Screenshot 2021-11-20 at 12 56 58" src="https://user-images.githubusercontent.com/11652564/142718397-2a55f10c-6dc7-4725-ba40-b322e5fa0385.png">

### final code

- post.py

```
from fastapi import FastAPI, Response, status, HTTPException, Depends, APIRouter
from sqlalchemy.orm import Session
from typing import List
from .. import models, schemas, oauth2
from ..database import get_db

router = APIRouter(
    prefix="/posts",
    tags=["Posts"]
)

@router.get("/", response_model=List[schemas.Post])
def get_posts(db: Session = Depends(get_db), current_user: int = Depends(oauth2.get_curent_user)):
    posts = db.query(models.Post).all()
    return posts


@router.post("/", status_code=status.HTTP_201_CREATED, response_model=schemas.Post)
def create_posts(post: schemas.PostCreate, db: Session = Depends(get_db),
                 current_user: int = Depends(oauth2.get_curent_user)):
                 # this will force the user is logged in
    new_post = models.Post(**post.dict())
    db.add(new_post)
    db.commit()
    db.refresh(new_post)
    return new_post

@router.get("/{id}", response_model=schemas.Post)
def get_post(id: int, db: Session = Depends(get_db), current_user: int = Depends(oauth2.get_curent_user)):
    post = db.query(models.Post).filter(models.Post.id == id).first()
    if not post:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"post with id: {id} was not found")
    return post


@router.delete("/{id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(id: int, db: Session = Depends(get_db),
                current_user: int = Depends(oauth2.get_curent_user)):
    post = db.query(models.Post).filter(models.Post.id == id)

    if post.first() == None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"post with id: {id} was not found")

    post.delete(synchronize_session=False)
    db.commit()
    return Response(status_code=status.HTTP_204_NO_CONTENT)


@router.put("/{id}", response_model=schemas.Post)
def update_post(id: int, updated_post: schemas.PostCreate, db: Session = Depends(get_db),
                current_user: int = Depends(oauth2.get_curent_user)):
    post_query = db.query(models.Post).filter(models.Post.id == id)
    post = post_query.first()

    if post == None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"post with id: {id} was not found")

    post_query.update(updated_post.dict(), synchronize_session=False)
    db.commit()
    return post_query.first()
```

- user.py

```
from fastapi import FastAPI, Response, status, HTTPException, Depends, APIRouter
from sqlalchemy.orm import Session
from .. import models, schemas, utils
from ..database import get_db

router = APIRouter(
    prefix="/users",
    tags=["Users"]
)

@router.post("/", status_code=status.HTTP_201_CREATED, response_model=schemas.UserOut)
def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
    hashed_password = utils.hash(user.password)
    user.password = hashed_password
    new_user = models.User(**user.dict())
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user


@router.get("/{id}", response_model=schemas.UserOut)
def get_user(id: int, db: Session = Depends(get_db)):
    user = db.query(models.User).filter(models.User.id == id).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"user with id: {id} was not found")
    return user

```

- `auth.py`

```
from fastapi import FastAPI, Response, status, HTTPException, Depends, APIRouter
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session # database session
from .. import database, schemas, models, utils, oauth2
from ..database import get_db

router = APIRouter(tags=["Authentication"])


@router.post("/login", response_model=schemas.Token) # user has to provide the cred
def login(user_credentials: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):

    user = db.query(models.User).filter(models.User.email == user_credentials.username).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN,
                            detail=f"Invalid Credentials")

    if not utils.verify(user_credentials.password, user.password):
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN,
                            detail=f"Invalid Credentials")

    # create a token
    # return token
    access_token = oauth2.create_access_token(data={"user_id": user.id}) # payload data

    return {"access_token": access_token, "token_type": "nearer"}

```

- oauth.py

```
from . import database, schemas, models
from jose import JWTError, jwt
from datetime import datetime, timedelta
from . import schemas
from fastapi.security import OAuth2PasswordBearer
from fastapi import Depends, HTTPException, status
from sqlalchemy.orm import Session, query


oauth_scheme = OAuth2PasswordBearer(tokenUrl='token')


# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30 # min

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})

    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

    return encoded_jwt


def verify_access_token(token: str, credentials_exception):
    try:
        print(token)
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        id: str = payload.get("user_id")

        if id is None:
            raise credentials_exception
        token_data = schemas.TokenData(id=id)
    except JWTError:
        raise credentials_exception

    return token_data

def get_curent_user(token: str = Depends(oauth_scheme),
                    db: Session = Depends(database.get_db)):
    credentials_exception = HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,
                                          detail=f"Could not validate credentials",
                                          headers={"WWW-Authenicate": "Bearer"})
    token = verify_access_token(token, credentials_exception)
    user = db.query(models.User).filter(models.User.id == token.id).first()
    return user

```
