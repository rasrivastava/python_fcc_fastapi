# JWT Token Authentication

![Screenshot 2021-11-16 at 23 43 00](https://user-images.githubusercontent.com/11652564/142041963-cd1b5578-4aeb-44c6-9ae2-230975cccdce.png)

(1) (`Client`): `Client` will Login with username and password to the `server` using the API created

(2) (`API`): if credentials are valid then the API will sigh a JWT token and send back the token to the client

(3) (`Client`): Client request for a post, so, the post id along with token will be sent to API, API will first verify the token

(4) (`API`) if the toke matched, then the related data will be sent to the client

![Screenshot 2021-11-16 at 23 47 31](https://user-images.githubusercontent.com/11652564/142042596-9fc68b08-41bc-4899-8690-3f2739a013a7.png)

- **NOTE:** token is not encrypted at any step this is done to just check if the data collected i s not manuplulated, token is made made up of three pieces:

(1) **HEADER**: Algo (ex: alh: HS256) and token type (ex: typ: JWT)

(2) **PAYLOAD**: Data (so, payload is also not encrypted, so the data can be such as **id**, or user type (admin, dev)): **NOTE**: we always want to keeep the payload light

(3) **VERIFY SIGNATURE**:
    - `header`: as menntioned above with base64 encode
    - `payload`: as mentioned above with base64 encode
    - `secret`: **unique password** will be known by API client
    - the combination of three will be a `signature` with base64 encode, again note, this signature will not be encrypted, this is created to just to be sure that **the three data collected** is not happered (manipulated) by anymean.

![Screenshot 2021-11-16 at 23 59 34](https://user-images.githubusercontent.com/11652564/142044360-12219299-1657-400e-95c8-b828f6cd93b2.png)

- it will be blocked as the `secret`: **unique password** will be known by API client
- **NOTE**: anyone can see the token but can't created a new token to manupulate the data as it will require the secreat and we know the secreat used a uique password which was generated by API, therefore anyone see the token but generate a new token which passes this authentication.

![Screenshot 2021-11-17 at 00 11 33](https://user-images.githubusercontent.com/11652564/142045988-f9dfa466-70de-4608-b625-2e7ff207ec00.png)

- **schemas.py**

```
class UserLogin(BaseModel):
    email: EmailStr
    password: str
```
- **utils.py**

```
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto") # what is hashing algo to be used

def hash(password: str):
    return pwd_context.hash(password)


def verify(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

```

- **auth.py**

```
from fastapi import FastAPI, Response, status, HTTPException, Depends, APIRouter
from sqlalchemy.orm import Session # database session
from .. import database, schemas, models, utils
from ..database import get_db

router = APIRouter(tags=["Authentication"])


@router.post("/login") # user has to provide the cred
def login(user_credentials: schemas.UserLogin, db: Session = Depends(get_db)):
    user = db.query(models.User).filter(models.User.email == user_credentials.email).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Invalid Credentials")

    if not utils.verify(user_credentials.password, user.password):
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Invalid Credentials")

    # create a token
    # return token
    return {"token": "example"}
```

- **main.py** `apptest.include_router(auth.router)`

```
from fastapi import FastAPI
from .database import engine
from .routers import post, user, auth
from . import models

models.Base.metadata.create_all(bind=engine)

apptest = FastAPI()

apptest.include_router(post.router)
apptest.include_router(user.router)
apptest.include_router(auth.router)


@apptest.get("/")
def root():
    return "Welcome Family"
```

## python-jose

https://fastapi.tiangolo.com/pt/tutorial/security/oauth2-jwt/#install-python-jose

- We need to install python-jose to generate and verify the JWT tokens in Python


- **oauth.py**

```
from jose import JWTError, jwt
from datetime import datetime, timedelta

# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30 # min

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.now() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})

    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

    return encoded_jwt
```

- **auth.py**

```
from fastapi import FastAPI, Response, status, HTTPException, Depends, APIRouter
from sqlalchemy.orm import Session # database session
from .. import database, schemas, models, utils, oauth
from ..database import get_db

router = APIRouter(tags=["Authentication"])


@router.post("/login") # user has to provide the cred
def login(user_credentials: schemas.UserLogin, db: Session = Depends(get_db)):
    user = db.query(models.User).filter(models.User.email == user_credentials.email).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Invalid Credentials")

    if not utils.verify(user_credentials.password, user.password):
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Invalid Credentials")

    # create a token
    # return token
    access_token = oauth.create_access_token(data={"user_id": user.id}) # payload data

    return {"access_token": access_token, "token_type": "nearer"}
```

- `http://127.0.0.1:8000/login` (POST)

- input

```
{
    "email": "nick1@gmail.com",
    "password": "nick1"
}
```

- output

```
{
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo4LCJleHAiOjE2MzczNjQ1Njl9.kpk_BwO_ixYypyk5VmxlilXNrpV2xOAaj2MHlHh_lCU",
    "token_type": "nearer"
}
```
